//! LLVM IR parser
//!
//! Based on https://llvm.org/docs/LangRef.html (https://web.archive.org/web/20240120071938/https://llvm.org/docs/LangRef.html)

WHITESPACE = _{ " " | "\t" | "\r" | "\n" | (";" ~ (!NEWLINE ~ ANY)* ~ NEWLINE) }

uint = @{ "0" | (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
int  = @{ uint | ("-" ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }

id  = @{ (ASCII_ALPHANUMERIC | "_" | "." | "-")+ }
uid = @{ "%" ~ (string | id) }
gid = @{ "@" ~ (string | id) }

string = ${ "\"" ~ inner ~ "\"" }
inner  = @{ char* }
char   =  {
    !("\"" | "\\") ~ ANY
  | "\\\\"
  | "\\" ~ ('0'..'9' | 'A'..'F'){2}
}

// | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t") // FIXME: check if this is even legal llvm ir syntax
// | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4}) // FIXME: check if this is even legal llvm ir syntax

module = { SOI ~ definition* ~ EOI }

linkage = {
    "private"
  | "internal"
  | "available_externally"
  | "linkonce"
  | "weak"
  | "common"
  | "appending"
  | "extern_weak"
  | "linkonce_odr"
  | "weak_odr"
  | "external"
}

cconv = {
    "ccc"
  | "fastcc"
  | "coldcc"
  | "ghccc"
  | "cc 11"
  | "anyregcc"
  | "preserve_mostcc"
  | "preserve_allcc"
  | "cxx_fast_tlscc"
  | "tailcc"
  | "swiftcc"
  | "swifttailcc"
  | "cfguard_checkcc" // | "cc <n>" // TODO: Any calling convention may be specified by number, allowing target-specific calling conventions to be used. Target specific calling conventions start at 64.
}

star      = { "*" }
ty        = { (id | uid | ty_array | ty_struct | ty_packed) ~ star* }
ty_array  = { "[" ~ uint ~ "x" ~ ty ~ "]" }
ty_struct = { "{" ~ (ty ~ ("," ~ ty)*)? ~ "}" }
ty_packed = { "<{" ~ (ty ~ ("," ~ ty)*)? ~ "}>" }

param_attr = {
    "zeroext"
  | "signext"
  | "inreg"
  | "byval" ~ "(" ~ ty ~ ")"
  | "byref" ~ "(" ~ ty ~ ")"
  | "preallocated" ~ "(" ~ ty ~ ")"
  | "inalloca" ~ "(" ~ ty ~ ")"
  | "sret" ~ "(" ~ ty ~ ")"
  | "elementtype" ~ "(" ~ ty ~ ")"
  | "align" ~ (uint | "(" ~ uint ~ ")")
  | "noalias"
  | "nocapture"
  | "nofree"
  | "nest"
  | "returned"
  | "nonnull"
  | "dereferenceable" ~ "(" ~ uint ~ ")"
  | "dereferenceable_or_null" ~ "(" ~ uint ~ ")"
  | "swiftself"
  | "swiftasync"
  | "swifterror"
  | "immarg"
  | "noundef" // | "nofpclass(<test mask>)" // TODO

  | "alignstack" ~ "(" ~ uint ~ ")"
  | "allocalign"
  | "allocptr"
  | "readnone"
  | "readonly"
  | "writeonly"
  | "writable"
  | "dead_on_unwind"
}

argument  = { ty ~ param_attr* ~ uid }
arguments = { (argument ~ ("," ~ argument)*)? }

addr_attr = { "unnamed_addr" | "local_unnamed_addr" }

func_attr = {
    "alignstack" ~ "(" ~ uint ~ ")" // | "alloc-family"="FAMILY" // TODO

  | "allockind" ~ "(" ~ string ~ ")"
  | "allocsize" ~ "(" ~ uint ~ ("," ~ uint) ~ ")"
  | "alwaysinline"
  | "builtin"
  | "cold"
  | "convergent"
  | "disable_sanitizer_instrumentation"
  | "\"dontcall-error\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "\"dontcall-warn\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "fn_ret_thunk_extern"
  | ("\"frame-pointer\"" ~ "=" ~ string)
  | "hot"
  | "inlinehint"
  | "jumptable" // | "memory(...)" // TODO

  | "minsize"
  | "naked"
  | "\"no-inline-line-tables\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "no-jump-tables" // FIXME: check if this is truly w/o '"'s (missing in the docs)

  | "nobuiltin"
  | "nocallback"
  | "noduplicate"
  | "nofree"
  | "noimplicitfloat"
  | "noinline"
  | "nomerge"
  | "nonlazybind"
  | "noprofile"
  | "skipprofile"
  | "noredzone"
  | "indirect-tls-seg-refs" // FIXME: check if this is truly w/o '"'s (missing in the docs)

  | "noreturn"
  | "norecurse"
  | "willreturn"
  | "nosync"
  | "nounwind"
  | "nosanitize_bounds"
  | "nosanitize_coverage"
  | "null_pointer_is_valid"
  | "optdebug"
  | "optforfuzzing"
  | "optnone"
  | "optsize"
  | "\"patchable-function\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "\"probe-stack\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "\"stack-probe-size\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "\"no-stack-arg-probe\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "returns_twice"
  | "safestack"
  | "sanitize_address"
  | "sanitize_memory"
  | "sanitize_thread"
  | "sanitize_hwaddress"
  | "sanitize_memtag"
  | "speculative_load_hardening"
  | "speculatable"
  | "ssp"
  | "sspstrong"
  | "sspreq"
  | "strictfp"
  | "\"denormal-fp-math\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "\"denormal-fp-math-f32\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "\"thunk\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "\"tls-load-hoist\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | "uwtable" ~ ("sync" | "async")?
  | "nocf_check"
  | "shadowcallstack"
  | "mustprogress" // | "warn-stack-size"="<threshold>" // TODO

  | "vscale_range" ~ "(" ~ uint ~ ("," ~ uint) ~ ")"
  | "\"nooutline\"" // FIXME: check if surrounding '"'s are required in LLVM IR

  | ("\"min-legal-vector-width\"" ~ "=" ~ string) // FIXME: find docs for this

  | ("\"no-trapping-math\"" ~ "=" ~ string) // FIXME: find docs for this

  | ("\"stack-protector-buffer-size\"" ~ "=" ~ string) // FIXME: find docs for this

  | ("\"target-cpu\"" ~ "=" ~ string) // FIXME: find docs for this

  | ("\"target-features\"" ~ "=" ~ string) // FIXME: find docs for this

  | ("\"tune-cpu\"" ~ "=" ~ string) // FIXME: find docs for this
}

attr_group = @{ "#" ~ uint }

addr_space = { "addrspace" ~ "(" ~ (uint | string) ~ ")" }

bop = {
    (("add" | "sub" | "mul" | "shl") ~ "nuw"? ~ "nsw"?)
  | (("udiv" | "sdiv" | "lshr" | "ashr") ~ "exact"?)
  | ("or" ~ "disjoint"?)
  | ("urem" | "srem" | "and" | "xor")
}

const_gep      = { "getelementptr" ~ inbounds? ~ "(" ~ ty ~ "," ~ const_val ~ ("," ~ const_val)+ ~ ")" }
const_inttoptr = { "inttoptr" ~ "(" ~ const_val ~ "to" ~ ty ~ ")" }
const_expr     = { const_gep | const_inttoptr }

val_poison = { "poison" }
val_undef  = { "undef" }
val_null   = { "null" }
val_true   = { "true" }
val_false  = { "false" }
val_struct = { "{" ~ (ty ~ val ~ ("," ~ ty ~ val)*)? ~ "}" }
val        = {
    int
  | uid
  | gid
  | val_true
  | val_false
  | val_poison
  | val_undef
  | val_null
  | val_struct
  | const_expr
}

align = { "," ~ "align" ~ uint }

tail            = { "tail" | "musttail" | "notail" }
fast_math_flags = {
    "nnan"
  | "ninf"
  | "nsz"
  | "arcp"
  | "contract"
  | "afn"
  | "reassoc"
  | "fast"
}

inalloca = { "inalloca" }
volatile = { "volatile" }

param          = { (param_metadata ~ metadata_val) | (param_metadata? ~ param_ty ~ param_attr* ~ val) }
param_metadata = { "metadata" }
param_ty       = { param_metadata? ~ ty }
params         = { (param ~ ("," ~ param)*)? }

stmt_bop          = { bop ~ ty ~ val ~ "," ~ val ~ ("," ~ named_meta)* }
stmt_alloca       = {
    "alloca" ~ inalloca? ~ ty ~ (align | ("," ~ ty ~ val ~ align?))? ~ ("," ~ addr_space)? ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_store        = {
    // TODO: !nontemporal, !invariant.group
    "store" ~ volatile? ~ ty ~ val ~ "," ~ ty ~ val ~ align? ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_call         = {
    tail? ~ "call" ~ fast_math_flags? ~ cconv? ~ param_attr* ~ addr_space? ~ ty ~ val ~ "(" ~ params ~ ")" ~ (func_attr | attr_group)* ~ ("," ~ metadata_name ~ metadata_num)*
}
inbounds          = { "inbounds" }
inrange           = { "inrange" }
stmt_gep_leg      = { "," ~ inrange? ~ ty ~ val }
stmt_gep          = {
    "getelementptr" ~ inbounds? ~ ty ~ "," ~ ty ~ val ~ stmt_gep_leg* ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_load         = {
    "load" ~ volatile? ~ ty ~ "," ~ ty ~ val ~ align ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_ptrtoint     = {
    "ptrtoint" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ metadata_name ~ metadata_num)*
}
cond              = {
    "eq"
  | "ne"
  | "ugt"
  | "uge"
  | "ult"
  | "ule"
  | "sgt"
  | "sge"
  | "slt"
  | "sle"
}
stmt_icmp         = {
    "icmp" ~ cond ~ ty ~ val ~ "," ~ val ~ ("," ~ metadata_name ~ metadata_num)*
}
selty             = {
    "i1"
  | ("<" ~ uint ~ "x" ~ "i1" ~ ">")
}
stmt_select       = {
    "select" ~ fast_math_flags? ~ selty ~ val ~ "," ~ ty ~ val ~ "," ~ ty ~ val ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_insertvalue  = {
    "insertvalue" ~ ty ~ val ~ "," ~ ty ~ val ~ "," ~ val ~ ("," ~ val)* ~ ("," ~ metadata_name ~ metadata_num)*
}
resultty          = { ty }
cleanup           = { "cleanup" }
clause            = { clause_catch | clause_filter }
clause_catch      = { "catch" ~ const_val }
clause_filter     = { "filter" ~ const_val }
stmt_landingpad   = {
    "landingpad" ~ resultty ~ (clause+ | (cleanup ~ clause*))
}
stmt_extractvalue = {
    "extractvalue" ~ ty ~ val ~ "," ~ val ~ ("," ~ val)* ~ ("," ~ named_meta)*
}
stmt_trunc        = {
    "trunc" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_zext         = {
    "zext" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_inttoptr     = {
    "inttoptr" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_phi_leg      = { "[" ~ val ~ "," ~ uid ~ "]" }
stmt_phi          = { "phi" ~ fast_math_flags? ~ ty ~ stmt_phi_leg ~ ("," ~ stmt_phi_leg)* }
stmt_rhs          = {
    stmt_bop
  | stmt_alloca
  | stmt_store
  | stmt_call
  | stmt_gep
  | stmt_load
  | stmt_ptrtoint
  | stmt_icmp
  | stmt_select
  | stmt_insertvalue
  | stmt_landingpad
  | stmt_extractvalue
  | stmt_trunc
  | stmt_zext
  | stmt_inttoptr
  | stmt_phi
}

stmt = {
    (uid ~ "=")? ~ stmt_rhs
}

term_ret         = { "ret" ~ ty ~ val? ~ ("," ~ metadata_name ~ metadata_num)* }
term_br          = { "br" ~ "label" ~ uid ~ ("," ~ metadata_name ~ metadata_num)* }
term_cbr         = { "br" ~ "i1" ~ val ~ "," ~ "label" ~ uid ~ "," ~ "label" ~ uid ~ ("," ~ metadata_name ~ metadata_num)* }
term_unreachable = { "unreachable" ~ ("," ~ metadata_name ~ metadata_num)* }
term_invoke      = {
    (uid ~ "=")? ~ "invoke" ~ cconv? ~ param_attr* ~ addr_space? ~ ty ~ val ~ "(" ~ params ~ ")" ~ (func_attr | attr_group)* ~ "to" ~ "label" ~ uid ~ "unwind" ~ "label" ~ uid ~ ("," ~ metadata_name ~ metadata_num)*
}
term_resume      = {
    "resume" ~ ty ~ val ~ ("," ~ metadata_name ~ metadata_num)*
}
term_switch_cond = {
    ty ~ val ~ "," ~ "label" ~ uid
}
term_switch      = {
    "switch" ~ ty ~ val ~ "," ~ "label" ~ uid ~ "[" ~ term_switch_cond+ ~ "]" ~ ("," ~ metadata_name ~ metadata_num)*
}
term             = { term_ret | term_br | term_cbr | term_unreachable | term_invoke | term_resume | term_switch }

label = {
    (id | string) ~ ":"
}

block      = {
    block_head ~ block_body ~ term
}
block_head = { label? }
block_body = { stmt* }

personality = { "personality" ~ ty ~ gid }

function = {
    "define" ~ linkage? ~ cconv? ~ param_attr* ~ ty ~ gid ~ "(" ~ arguments ~ ")" ~ addr_attr? ~ addr_space? ~ (func_attr | attr_group)* ~ personality? ~ named_meta* ~ "{" ~ block+ ~ "}"
}

const_val    =  { ty ~ (const_zinit | const_undef | const_str | const_packed | gid | int) }
const_zinit  =  { "zeroinitializer" }
const_undef  =  { "undef" }
const_str    = @{ "c" ~ string }
const_packed =  { "<{" ~ (const_val ~ (", " ~ const_val)*) ~ "}>" }

const_attr = { "global" | "constant" }

named_meta_name = @{ "!" ~ id }
named_meta_num  = @{ "!" ~ uint }
named_meta      =  { named_meta_name ~ named_meta_num }

linkage_int = {
    "private"
  | "internal"
  | "available_externally"
  | "linkonce"
  | "weak"
  | "common"
  | "appending"
  | "extern_weak"
  | "linkonce_odr"
  | "weak_odr"
}
linkage_ext = { "external" }

ident_type  = {
    uid ~ "=" ~ "type" ~ ty
}
ident_const = {
    gid ~ "=" ~ ((linkage_int? ~ addr_attr? ~ const_attr ~ const_val ~ align? ~ ("," ~ named_meta)*) | (linkage_ext ~ addr_attr? ~ const_attr ~ ty ~ align? ~ ("," ~ named_meta)*))
}

metadata_string = @{ "!" ~ string }
metadata_num    = @{ "!" ~ uint }
metadata_val    =  { metadata_string | (metadata_name ~ metadata_struct?) | (ty ~ int) }
// TODO: impl inner for struct
metadata_struct_array_entry =  { int | id }
metadata_struct_array       =  { (metadata_struct_array_entry ~ ("," ~ metadata_struct_array_entry)*)? }
metadata_struct             =  { "(" ~ (metadata_struct_array) ~ ")" }
metadata_node               =  {
    "distinct"? ~ "!{" ~ (metadata_val ~ ("," ~ metadata_val)*)? ~ "}"
}
metadata_prim               =  { metadata_node | metadata_string }
metadata_name               = @{ "!" ~ id }
metadata                    =  { metadata_name ~ "=" ~ metadata_node }

source_filename   = { "source_filename" ~ "=" ~ string }
target_datalayout = { "target" ~ "datalayout" ~ "=" ~ string }
target_triple     = { "target" ~ "triple" ~ "=" ~ string }
attributes        = { "attributes" ~ attr_group ~ "=" ~ "{" ~ func_attr* ~ "}" }

definition = {
    function
  | ident_type
  | ident_const
  | source_filename
  | target_datalayout
  | target_triple
  | attributes
  | metadata
}
