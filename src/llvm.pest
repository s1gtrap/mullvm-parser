//! LLVM IR parser
//!
//! Based on https://llvm.org/docs/LangRef.html (https://web.archive.org/web/20240120071938/https://llvm.org/docs/LangRef.html)

WHITESPACE = _{ " " | "\t" | "\r" | "\n" | (";" ~ (!NEWLINE ~ ANY)* ~ NEWLINE) }

uint       = @{ "0" | (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
int        = @{ uint | ("-" ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
hex        = @{ "0x" ~ HEX_DIGIT+ }
float_base = @{ "-"? ~ int ~ "." ~ ASCII_DIGIT+ }
float_exp  = @{ "e" ~ ("+" | "-") ~ ASCII_DIGIT+ }
float      = ${ float_base ~ float_exp? }

idchar = @{ ASCII_ALPHANUMERIC | "_" | "." | "-" }
id     = @{ !vararg ~ idchar+ }
uid    = @{ "%" ~ (string | id) }
gid    = @{ "@" ~ (string | id) }

string = ${ "\"" ~ inner ~ "\"" }
inner  = @{ char* }
char   =  {
    !("\"" | "\\") ~ ANY
  | "\\\\"
  | "\\" ~ ('0'..'9' | 'A'..'F'){2}
}

// | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t") // FIXME: check if this is even legal llvm ir syntax
// | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4}) // FIXME: check if this is even legal llvm ir syntax

module = { SOI ~ definition* ~ EOI }

linkage = {
    "private"
  | "internal"
  | "available_externally"
  | "linkonce"
  | "weak"
  | "common"
  | "appending"
  | "extern_weak"
  | "linkonce_odr"
  | "weak_odr"
  | "external"
}

cconv = {
    "fastcc"
  | "ccc"
  | "coldcc"
  | "ghccc" // | "cc 11" // TODO: figure out how it's supposed to be tokenized

  | "anyregcc"
  | "preserve_mostcc"
  | "preserve_allcc"
  | "cxx_fast_tlscc"
  | "tailcc"
  | "swiftcc"
  | "swifttailcc"
  | "cfguard_checkcc" // | "cc <n>" // TODO: Any calling convention may be specified by number, allowing target-specific calling conventions to be used. Target specific calling conventions start at 64.
}

vararg = { "..." }
fnty   = { ty ~ "(" ~ (ty ~ ("," ~ ty)* ~ ("," ~ vararg)? | vararg)? ~ ")" ~ star* }
selty  = {
    "i1"
  | ("<" ~ uint ~ "x" ~ "i1" ~ ">")
}

star      = { "*" }
ty        = { (id | uid | ty_array | ty_vector | ty_struct | ty_packed) ~ star* }
ty_array  = { "[" ~ uint ~ "x" ~ (fnty | ty) ~ "]" }
ty_vector = { "<" ~ uint ~ "x" ~ (fnty | ty) ~ ">" }
ty_struct = { "{" ~ ((fnty | ty) ~ ("," ~ (fnty | ty))*)? ~ "}" }
ty_packed = { "<{" ~ ((fnty | ty) ~ ("," ~ (fnty | ty))*)? ~ "}>" }

param_attr  = {
    "zeroext"
  | "signext"
  | "inreg"
  | "byval" ~ "(" ~ ty ~ ")"
  | "byref" ~ "(" ~ ty ~ ")"
  | "preallocated" ~ "(" ~ ty ~ ")"
  | "inalloca" ~ "(" ~ ty ~ ")"
  | "sret" ~ "(" ~ ty ~ ")"
  | "elementtype" ~ "(" ~ ty ~ ")"
  | "align" ~ (uint | "(" ~ uint ~ ")")
  | "noalias"
  | "nocapture"
  | "nofree"
  | "nest"
  | "returned"
  | "nonnull"
  | "dereferenceable" ~ "(" ~ uint ~ ")"
  | "dereferenceable_or_null" ~ "(" ~ uint ~ ")"
  | "swiftself"
  | "swiftasync"
  | "swifterror"
  | "immarg"
  | "noundef" // | "nofpclass(<test mask>)" // TODO

  | "alignstack" ~ "(" ~ uint ~ ")"
  | "allocalign"
  | "allocptr"
  | "readnone"
  | "readonly"
  | "writeonly"
  | "writable"
  | "dead_on_unwind"
}
param_attrs = { param_attr* }

argument  = { ty ~ param_attrs ~ uid? }
arguments = { (argument ~ ("," ~ argument)*)? }

addr_attr = { "unnamed_addr" | "local_unnamed_addr" }

func_attr_memory_value = {
    "none"
  | "readwrite"
  | "read"
  | "write"
}
func_attr_memory_key   = { "argmem" | "inaccessiblemem" }
func_attr_memory_field = {
    (func_attr_memory_key ~ ":")? ~ func_attr_memory_value
}

// func_attr = {
// (id | string) ~ (("(" ~ (uint | string) ~ ("," ~ (uint | string))* ~ ")") | "=" ~ string)?
// }
func_attr = {
    ("alignstack" ~ "(" ~ uint ~ ")")
  | ("\"alloc-family\"" ~ "=" ~ string)
  | ("allockind" ~ "(" ~ string ~ ")")
  | ("allocsize" ~ "(" ~ uint ~ ("," ~ uint)* ~ ")")
  | "alwaysinline"
  | "builtin"
  | "cold"
  | "convergent"
  | "disable_sanitizer_instrumentation"
  | "\"dontcall-error\""
  | "\"dontcall-warn\""
  | "fn_ret_thunk_extern"
  | ("\"frame-pointer\"" ~ "=" ~ string)
  | "hot"
  | "inlinehint"
  | "jumptable"
  | ("memory" ~ "(" ~ func_attr_memory_field ~ ")")
  | "minsize"
  | "naked"
  | "\"no-inline-line-tables\""
  | "\"no-jump-tables\""
  | "nobuiltin"
  | "nocallback"
  | "noduplicate"
  | "nofree"
  | "noimplicitfloat"
  | "noinline"
  | "nomerge"
  | "nonlazybind"
  | "noprofile"
  | "skipprofile"
  | "noredzone"
  | "\"indirect-tls-seg-refs\""
  | "noreturn"
  | "norecurse"
  | "willreturn"
  | "nosync"
  | "nounwind"
  | "nosanitize_bounds"
  | "nosanitize_coverage"
  | "null_pointer_is_valid"
  | "optdebug"
  | "optforfuzzing"
  | "optnone"
  | "optsize"
  | "\"patchable-function\""
  | ("\"probe-stack\"" ~ "=" ~ string)
  | "\"stack-probe-size\""
  | "\"no-stack-arg-probe\""
  | "returns_twice"
  | "safestack"
  | "sanitize_address"
  | "sanitize_memory"
  | "sanitize_thread"
  | "sanitize_hwaddress"
  | "sanitize_memtag"
  | "speculative_load_hardening"
  | "speculatable"
  | "ssp"
  | "sspstrong"
  | "sspreq"
  | "strictfp"
  | "\"denormal-fp-math\""
  | "\"denormal-fp-math-f32\""
  | "\"thunk\"" // FIXME: check if surrounding '"'s are required since it has no dashes!?

  | "\"tls-load-hoist\""
  | "uwtable" ~ ("sync" | "async")?
  | "nocf_check"
  | "shadowcallstack"
  | "mustprogress" // | "warn-stack-size"="<threshold>" // TODO

  | "vscale_range" ~ "(" ~ uint ~ ("," ~ uint) ~ ")"
  | "\"nooutline\"" // FIXME: check if surrounding '"'s are required since it has no dashes!?

  | ("\"min-legal-vector-width\"" ~ "=" ~ string)
  | ("\"no-trapping-math\"" ~ "=" ~ string)
  | ("\"stack-protector-buffer-size\"" ~ "=" ~ string)
  | ("\"target-cpu\"" ~ "=" ~ string)
  | ("\"target-features\"" ~ "=" ~ string)
  | ("\"tune-cpu\"" ~ "=" ~ string)
  | ("\"no-frame-pointer-elim\"" ~ "=" ~ string)
  | ("\"no-frame-pointer-elim-non-leaf\"" ~ "=" ~ string)
}

attr_group = @{ "#" ~ uint }

addr_space = { "addrspace" ~ "(" ~ (uint | string) ~ ")" }

add      = { "add" }
and      = { "and" }
ashr     = { "ashr" }
disjoint = { "disjoint" }
fadd     = { "fadd" }
fdiv     = { "fdiv" }
fmul     = { "fmul" }
fsub     = { "fsub" }
lshr     = { "lshr" }
mul      = { "mul" }
or       = { "or" }
sdiv     = { "sdiv" }
shl      = { "shl" }
srem     = { "srem" }
sub      = { "sub" }
udiv     = { "udiv" }
xor      = { "xor" }
urem     = { "urem" }
nuw      = { "nuw" }
nsw      = { "nsw" }
exact    = { "exact" }
// disjoint = { "disjoint" }
bop = {
    ((add | sub | mul | shl) ~ nuw? ~ nsw?)
  | ((udiv | sdiv | lshr | ashr) ~ exact?)
  | (or ~ disjoint?)
  | (urem | srem | and | xor)
  | ((fadd | fdiv | fmul | fsub) ~ fast_math_flags?)
}

const_gep      = { "getelementptr" ~ inbounds? ~ "(" ~ ty ~ "," ~ const_val ~ ("," ~ const_val)+ ~ ")" }
const_inttoptr = { "inttoptr" ~ "(" ~ const_val ~ "to" ~ ty ~ ")" }
const_bitcast  = { "bitcast" ~ "(" ~ const_val ~ "to" ~ (fnty | ty) ~ ")" }
const_trunc    = { "trunc" ~ "(" ~ const_val ~ "to" ~ ty ~ ")" }
const_ptrtoint = { "ptrtoint" ~ "(" ~ const_val ~ "to" ~ ty ~ ")" }
const_binop    = { bop ~ "(" ~ const_val ~ "," ~ const_val ~ ")" }
const_expr     = { const_gep | const_inttoptr | const_bitcast | const_trunc | const_ptrtoint | const_binop }

val_poison = { "poison" }
val_undef  = { "undef" }
val_null   = { "null" }
val_zinit  = { "zeroinitializer" }
val_true   = { "true" }
val_false  = { "false" }
val_struct = { "{" ~ (ty ~ val ~ ("," ~ ty ~ val)*)? ~ "}" }
val_vector = { "<" ~ (ty ~ val ~ ("," ~ ty ~ val)*)? ~ ">" }
val        = {
    float
  | hex
  | int
  | uid
  | gid
  | val_true
  | val_false
  | val_poison
  | val_undef
  | val_null
  | val_zinit
  | val_struct
  | val_vector
  | const_expr
}

align = { "," ~ "align" ~ uint }

tail            = { "tail" | "musttail" | "notail" }
fast_math_flags = {
    "nnan"
  | "ninf"
  | "nsz"
  | "arcp"
  | "contract"
  | "afn"
  | "reassoc"
  | "fast"
}

inalloca = { "inalloca" }
volatile = { "volatile" }

metadata_call = { metadata_name ~ "(" ~ params ~ ")" }
param         = { (param_metadata ~ metadata_call) | (param_metadata ~ metadata_val) | (param_metadata? ~ (fnty | ty) ~ param_attrs ~ val) }

param_metadata = { "metadata" }
params         = { (param ~ ("," ~ param)*)? }

ordering = {
    "unordered"
  | "monotonic"
  | "acquire"
  | "release"
  | "acq_rel"
  | "seq_cst"
}

// keywords

sideeffect   = { "sideeffect" }
alignstack   = { "alignstack" }
inteldialect = { "inteldialect" }
unwind       = { "unwind" }

inbounds = { "inbounds" }
inrange  = { "inrange" }

weak = { "weak" }

// enums

atomicrmw_op = {
    "xchg"
  | "add"
  | "sub"
  | "and"
  | "nand"
  | "or"
  | "xor"
  | "max"
  | "min"
  | "umax"
  | "umin"
  | "fadd"
  | "fsub"
  | "fmax"
  | "fmin"
  | "uinc_wrap"
  | "udec_wrap"
}
cond         = {
    "eq"
  | "ne"
  | "ugt"
  | "uge"
  | "ult"
  | "ule"
  | "sgt"
  | "sge"
  | "slt"
  | "sle"
}
fcond        = {
    "false"
  | "oeq"
  | "ogt"
  | "oge"
  | "olt"
  | "ole"
  | "one"
  | "ord"
  | "ueq"
  | "ugt"
  | "uge"
  | "ult"
  | "ule"
  | "une"
  | "uno"
  | "true"
}

stmt_alloca         = {
    "alloca" ~ inalloca? ~ ty ~ (align | ("," ~ ty ~ val ~ align?))? ~ ("," ~ addr_space)? ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_atomicrmw      = { "atomicrmw" ~ volatile? ~ atomicrmw_op ~ "ptr" ~ val ~ "," ~ ty ~ val ~ ordering ~ align? ~ ("," ~ named_meta)* }
stmt_bitcast        = {
    "bitcast" ~ (fnty | ty) ~ val ~ "to" ~ (fnty | ty) ~ ("," ~ named_meta)*
}
stmt_bop            = { bop ~ ty ~ val ~ "," ~ val ~ ("," ~ named_meta)* }
stmt_call_asm       = {
    "call" ~ (fnty | ty) ~ "asm" ~ sideeffect? ~ alignstack? ~ inteldialect? ~ unwind? ~ string ~ "," ~ string ~ "(" ~ params ~ ")"* ~ ("," ~ named_meta)*
}
stmt_call           = {
    tail? ~ "call" ~ (fast_math_flags ~ !"cc")? ~ cconv? ~ param_attrs ~ addr_space? ~ (fnty | ty) ~ val ~ "(" ~ params ~ ")" ~ (func_attr | attr_group)* ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_cmpxchg        = { "cmpxchg" ~ weak? ~ volatile? ~ ty ~ val ~ "," ~ ty ~ val ~ "," ~ ty ~ val ~ ordering ~ ordering ~ align? ~ ("," ~ named_meta)* }
stmt_gep_leg        = { "," ~ inrange? ~ ty ~ val }
stmt_gep            = {
    "getelementptr" ~ inbounds? ~ ty ~ "," ~ ty ~ val ~ stmt_gep_leg* ~ ("," ~ named_meta)*
}
stmt_load_atomic    = {
    "load" ~ "atomic" ~ volatile? ~ ty ~ "," ~ ty ~ val ~ ordering ~ align ~ ("," ~ named_meta)*
}
stmt_load           = {
    "load" ~ volatile? ~ ty ~ "," ~ ty ~ val ~ align? ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_icmp           = {
    "icmp" ~ cond ~ ty ~ val ~ "," ~ val ~ ("," ~ named_meta)*
}
stmt_fcmp           = {
    "fcmp" ~ fast_math_flags* ~ fcond ~ ty ~ val ~ "," ~ val ~ ("," ~ named_meta)*
}
stmt_select         = {
    "select" ~ fast_math_flags? ~ selty ~ val ~ "," ~ ty ~ val ~ "," ~ ty ~ val ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_insertvalue    = {
    "insertvalue" ~ ty ~ val ~ "," ~ ty ~ val ~ "," ~ val ~ ("," ~ val)* ~ ("," ~ metadata_name ~ metadata_num)*
}
resultty            = { ty }
cleanup             = { "cleanup" }
clause              = { clause_catch | clause_filter }
clause_catch        = { "catch" ~ const_val }
clause_filter       = { "filter" ~ const_val }
stmt_landingpad     = {
    "landingpad" ~ resultty ~ (clause+ | (cleanup ~ clause*))
}
stmt_extractvalue   = {
    "extractvalue" ~ ty ~ val ~ "," ~ val ~ ("," ~ val)* ~ ("," ~ named_meta)*
}
stmt_trunc          = {
    "trunc" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_zext           = {
    "zext" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_inttoptr       = {
    "inttoptr" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_phi_leg        = { "[" ~ val ~ "," ~ uid ~ "]" }
stmt_phi            = { "phi" ~ fast_math_flags? ~ ty ~ stmt_phi_leg ~ ("," ~ stmt_phi_leg)* ~ ("," ~ named_meta)* }
stmt_fence          = { "fence" ~ ordering ~ ("," ~ named_meta)* }
stmt_fptosi         = {
    "fptosi" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_freeze         = {
    "freeze" ~ ty ~ val ~ ("," ~ named_meta)*
}
stmt_extractelement = {
    "extractelement" ~ ty ~ val ~ "," ~ ty ~ val ~ ("," ~ named_meta)*
}
stmt_shufflevector  = {
    "shufflevector" ~ ty ~ val ~ "," ~ ty ~ val ~ "," ~ ty ~ val ~ ("," ~ named_meta)*
}
stmt_sitofp         = {
    "sitofp" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_uitofp         = {
    "uitofp" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_ptrtoint       = {
    "ptrtoint" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_sext           = {
    "sext" ~ ty ~ val ~ "to" ~ ty ~ ("," ~ named_meta)*
}
stmt_store          = {
    // TODO: !nontemporal, !invariant.group
    "store" ~ volatile? ~ (fnty | ty) ~ val ~ "," ~ (fnty | ty) ~ val ~ align? ~ ("," ~ metadata_name ~ metadata_num)*
}
stmt_store_atomic   = {
    "store" ~ "atomic" ~ volatile? ~ (fnty | ty) ~ val ~ "," ~ (fnty | ty) ~ val ~ ordering ~ align ~ ("," ~ named_meta)*
}
stmt_insertelement  = { "insertelement" ~ ty ~ val ~ "," ~ ty ~ val ~ "," ~ ty ~ val ~ ("," ~ named_meta)* }
stmt_rhs            = {
    stmt_alloca
  | stmt_atomicrmw
  | stmt_bitcast
  | stmt_bop
  | stmt_call
  | stmt_call_asm
  | stmt_cmpxchg
  | stmt_extractelement
  | stmt_extractvalue
  | stmt_fcmp
  | stmt_fence
  | stmt_fptosi
  | stmt_freeze
  | stmt_gep
  | stmt_icmp
  | stmt_insertelement
  | stmt_insertvalue
  | stmt_inttoptr
  | stmt_landingpad
  | stmt_load
  | stmt_load_atomic
  | stmt_phi
  | stmt_ptrtoint
  | stmt_select
  | stmt_sext
  | stmt_shufflevector
  | stmt_sitofp
  | stmt_store
  | stmt_store_atomic
  | stmt_trunc
  | stmt_uitofp
  | stmt_zext
}

stmt = {
    (uid ~ "=")? ~ stmt_rhs
}

term_ret         = { "ret" ~ ty ~ val? ~ ("," ~ metadata_name ~ metadata_num)* }
term_br          = { "br" ~ "label" ~ uid ~ ("," ~ metadata_name ~ metadata_num)* }
term_cbr         = { "br" ~ "i1" ~ val ~ "," ~ "label" ~ uid ~ "," ~ "label" ~ uid ~ ("," ~ metadata_name ~ metadata_num)* }
term_unreachable = { "unreachable" ~ ("," ~ metadata_name ~ metadata_num)* }
term_invoke      = {
    (uid ~ "=")? ~ "invoke" ~ cconv? ~ param_attr* ~ addr_space? ~ ty ~ val ~ "(" ~ params ~ ")" ~ (func_attr | attr_group)* ~ "to" ~ "label" ~ uid ~ "unwind" ~ "label" ~ uid ~ ("," ~ metadata_name ~ metadata_num)*
}
term_resume      = {
    "resume" ~ ty ~ val ~ ("," ~ metadata_name ~ metadata_num)*
}
term_switch_cond = {
    ty ~ val ~ "," ~ "label" ~ uid
}
term_switch      = {
    "switch" ~ ty ~ val ~ "," ~ "label" ~ uid ~ "[" ~ term_switch_cond+ ~ "]" ~ ("," ~ metadata_name ~ metadata_num)*
}
term             = { term_ret | term_br | term_cbr | term_unreachable | term_invoke | term_resume | term_switch }

label = {
    (id | string) ~ ":"
}

block      = {
    block_head ~ block_body ~ term
}
block_head = { label? }
block_body = { stmt* }

personality = { "personality" ~ (fnty | ty) ~ gid }

fn_align = { "align" ~ uint }
function = {
    "define" ~ linkage? ~ cconv? ~ param_attrs ~ ty ~ gid ~ "(" ~ arguments ~ ")" ~ addr_attr? ~ addr_space? ~ (func_attr | attr_group)* ~ fn_align? ~ personality? ~ named_meta* ~ "{" ~ block+ ~ "}"
}

const_val_opt =  { (fnty | ty) ~ ((const_zinit | const_undef | const_str | const_array | const_struct | const_packed | const_null | const_false | const_true | const_expr | gid | int) ~ !"=")? }
const_val     =  { (fnty | ty) ~ (const_zinit | const_undef | const_str | const_array | const_struct | const_packed | const_null | const_false | const_true | const_expr | gid | int) }
const_zinit   =  { "zeroinitializer" }
const_undef   =  { "undef" }
const_str     = @{ "c" ~ string }
const_array   =  { "[" ~ (const_val ~ (", " ~ const_val)*)? ~ "]" }
const_struct  =  { "{" ~ (const_val ~ (", " ~ const_val)*)? ~ "}" }
const_packed  =  { "<{" ~ (const_val ~ (", " ~ const_val)*)? ~ "}>" }
const_null    =  { "null" }
const_false   =  { "false" }
const_true    =  { "true" }
const_attr    =  { "global" | "constant" }

named_meta_name = @{ "!" ~ id }
named_meta_num  = @{ "!" ~ uint }
named_meta      =  { named_meta_name ~ named_meta_num }

thread_local = {
    "thread_local" ~ ("(" ~ id ~ ")")?
}

ident_type  = {
    uid ~ "=" ~ "type" ~ ty
}
section     = { "section" ~ string }
ident_const = {
    gid ~ "=" ~ (linkage? ~ thread_local? ~ addr_attr? ~ const_attr ~ const_val_opt ~ ("," ~ section)? ~ align? ~ ("," ~ named_meta)*)
}

distinct = { "distinct" }

metadata_string = @{ "!" ~ string }
metadata_num    = @{ "!" ~ uint }
metadata_val    =  { metadata_string | (metadata_name ~ metadata_struct?) | (ty ~ int) | string | val }
metadata_field  =  { id ~ ":" ~ (metadata_val | (id ~ ("|" ~ id)*)) }
// TODO: impl inner for struct
metadata_struct_array_entry =  { int | id }
metadata_struct_array       =  { (metadata_struct_array_entry ~ ("," ~ metadata_struct_array_entry)*)? }
metadata_struct             =  { "(" ~ (metadata_struct_array) ~ ")" }
metadata_node               =  {
    (distinct? ~ metadata_name ~ "(" ~ (metadata_field ~ ("," ~ metadata_field)*) ~ ")")
  | (distinct? ~ "!{" ~ (metadata_val ~ ("," ~ metadata_val)*)? ~ "}")
}
metadata_prim               =  { metadata_node | metadata_string }
metadata_name               = @{ "!" ~ id }
metadata                    =  { metadata_name ~ "=" ~ metadata_node }

source_filename   = { "source_filename" ~ "=" ~ string }
target_datalayout = { "target" ~ "datalayout" ~ "=" ~ string }
target_triple     = { "target" ~ "triple" ~ "=" ~ string }

attribute_field = { id ~ ":" ~ id | id | string }
attribute       = { (string | id) ~ ("=" ~ string | "(" ~ (attribute_field ~ ("," ~ attribute_field)*) ~ ")")? }
attributes      = { "attributes" ~ attr_group ~ "=" ~ "{" ~ attribute* ~ "}" }

declarg  = { (fnty | ty) ~ param_attrs }
declargs = { ((declarg ~ ("," ~ declarg)* ~ ("," ~ vararg)?) | vararg)? }
declare  = {
    "declare" ~ linkage? ~ cconv? ~ param_attrs ~ (fnty | ty) ~ gid ~ "(" ~ declargs ~ ")" ~ addr_attr? ~ addr_space? ~ (func_attr | attr_group)* ~ personality? ~ named_meta*
}

alias = {
    gid ~ "=" ~ linkage? ~ thread_local? ~ addr_attr? ~ "alias" ~ (fnty | ty) ~ "," ~ (fnty | ty) ~ gid
}

definition = {
    function
  | alias
  | declare
  | ident_type
  | ident_const
  | source_filename
  | target_datalayout
  | target_triple
  | attributes
  | metadata
}
